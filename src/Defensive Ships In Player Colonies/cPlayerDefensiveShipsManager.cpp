#include "stdafx.h"
#include "cPlayerDefensiveShipsManager.h"

cPlayerDefensiveShipsManager* cPlayerDefensiveShipsManager::instance = nullptr;

/// AUTOGENERATED METHODS ///

int cPlayerDefensiveShipsManager::AddRef() {
	return Simulator::cStrategy::AddRef();
}
int cPlayerDefensiveShipsManager::Release() {
	return Simulator::cStrategy::Release();
}

const char* cPlayerDefensiveShipsManager::GetName() const {
	return "Defensive_Ships_In_Player_Colonies::cPlayerDefensiveShipsManager";
}

bool cPlayerDefensiveShipsManager::Write(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Write(stream);
}
bool cPlayerDefensiveShipsManager::Read(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Read(stream);
}

/// END OF AUTOGENERATED METHODS ///
////////////////////////////////////

bool cPlayerDefensiveShipsManager::WriteToXML(XmlSerializer* xml) {
	return true;
}

Simulator::Attribute cPlayerDefensiveShipsManager::ATTRIBUTES[] = {
	// Add more attributes here
	// This one must always be at the end
	Simulator::Attribute()
};

void cPlayerDefensiveShipsManager::Initialize() {
	instance = this;
	elapsedTime = 0;
	cycleInterval = 60000 * 5;

	MessageManager.AddListener(this, SimulatorMessages::kMsgCombatantKilled);
	PropertyListPtr propListRelationship;
	PropManager.GetPropertyList(0x4E5855B9, 0x0568de14, propListRelationship);

	eastl::vector<int> readVector;
	int maxDefenders;
	int minDefenders;

	App::Property::GetArrayInt32(propListRelationship.get(), 0x067B69EB, readVector);
	maxDefenders = readVector[0];
	App::Property::GetArrayInt32(propListRelationship.get(), 0x067B69D8, readVector);
	minDefenders = readVector[0];
	playerColonyDefenders = (maxDefenders + minDefenders + 1) / 2; // Average with rounding up.


	App::Property::GetArrayInt32(propListRelationship.get(), 0x067B69F1, readVector);
	maxDefenders = readVector[0];
	App::Property::GetArrayInt32(propListRelationship.get(), 0x067B69E3, readVector);
	minDefenders = readVector[0];
	playerHomeworldDefenders = (maxDefenders + minDefenders + 1) / 2;

	App::Property::GetArrayInt32(propListRelationship.get(), 0x067B69D0, readVector);
	maxDefenders = readVector[0];
	App::Property::GetArrayInt32(propListRelationship.get(), 0x067B69C4, readVector);
	minDefenders = readVector[0];
	playerOutpostDefenders = (maxDefenders + minDefenders + 1) / 2;

	PropertyListPtr propListSpaceCombat;
	PropManager.GetPropertyList(id(u"SpaceCombat"), 0x02ae0c7e, propListSpaceCombat);

	App::Property::GetFloat(propListSpaceCombat.get(), 0x05C2CBC5, reinforceTime);

}

void cPlayerDefensiveShipsManager::Dispose() {
	
}

void cPlayerDefensiveShipsManager::Update(int deltaTime, int deltaGameTime) {
	if (IsSpaceGame()) {
		elapsedTime += deltaGameTime;
		if (elapsedTime > cycleInterval) {
			// Every cycle remove expired scheduledTasks
			for (auto it = scheduledTasks.begin(); it != scheduledTasks.end(); ) {
				if ((*it)->HasExecuted()) {
					it = scheduledTasks.erase(it);
				}
				else {
					++it;
				}
			}
			elapsedTime = 0;
		}
	}
}

void cPlayerDefensiveShipsManager::OnModeEntered(uint32_t previousModeID, uint32_t newModeID) {
	if (newModeID == GameModeIDs::kGameSpace) {
		elapsedTime = 0;
	}
	cStrategy::OnModeEntered(previousModeID, newModeID); //idk if it is necessary.
}

void cPlayerDefensiveShipsManager::OnModeExited(uint32_t previousModeID, uint32_t newModeID) {
	if (previousModeID == GameModeIDs::kGameSpace) {
		for (SimScheduledTaskListenerPtr scheluded : scheduledTasks) {
			if (!scheluded->HasExecuted()) {
				Simulator::RemoveScheduledTask(scheluded); // Cancel active scheduledTasks.
			}
		}
		scheduledTasks.clear();
		while (!planetsToReinforce.empty()) {
			planetsToReinforce.pop();
		}
		planetDefenderShips.clear();

	}
	cStrategy::OnModeExited(previousModeID, newModeID);
}

bool cPlayerDefensiveShipsManager::HandleMessage(uint32_t messageID, void* msg) {
	if (IsSpaceGame() && messageID == SimulatorMessages::kMsgCombatantKilled) {
		CombatantKilledMessage* msgInfo = static_cast<CombatantKilledMessage*>(msg);
		cCombatant* combatant = msgInfo->GetCombatant();
		cGameDataUFO* ufo = object_cast<cGameDataUFO>(combatant);
		if (ufo &&
			GetCurrentContext() == SpaceContext::Planet &&
			ufo->mUFOType == static_cast<int>(UfoType::Defender) &&
			ufo->mPoliticalID == GetPlayerEmpireID()) {
			DecreaseDefendersOnPlanet(GetActivePlanetRecord());
		}
	}
	return true;
}

cPlayerDefensiveShipsManager* cPlayerDefensiveShipsManager::Get(){
	return instance;
}

cGameDataUFO* cPlayerDefensiveShipsManager::SpawnPlayerDefensiveShip() {
	int* pointerToPoliticalId = &GetPlayerEmpire()->mPoliticalID;
	ResourceKey* ufoKey = &GetPlayerEmpire()->mUFOKey;
	return STATIC_CALL(Address(ModAPI::ChooseAddress(0x0102bbb0, 0x0102acc0)), cGameDataUFO*, Args(UfoType, int*, ResourceKey*), Args(UfoType::Defender, pointerToPoliticalId, ufoKey));
}

int cPlayerDefensiveShipsManager::GetMaxDefenders(cPlanetRecord* planet) {
	if (planet->mbHomeWorld) {
		return playerHomeworldDefenders;
	}
	else if (planet->mType == PlanetType::T0) {
		return playerOutpostDefenders;
	}
	else {
		return playerColonyDefenders;
	}
}

int cPlayerDefensiveShipsManager::GetDefendersOnPlanet(cPlanetRecord* planet) {
	auto it = planetDefenderShips.find(planet);
	if (it != planetDefenderShips.end()) { // if it != planetDefenderShips.end() means that the planet is in the map
		return it->second;
	}
	else {
		return GetMaxDefenders(planet);
	}
}

void cPlayerDefensiveShipsManager::DecreaseDefendersOnPlanet(cPlanetRecord* planet) {
	auto it = planetDefenderShips.find(planet);
	if (it != planetDefenderShips.end()) { // if it != planetDefenderShips.end() means that the planet is in the map
		it->second--;
	}
	else {
		planetDefenderShips[cPlanetRecordPtr(planet)] = GetMaxDefenders(planet) - 1;
		SimScheduledTaskListenerPtr scheduler = Simulator::ScheduleTask(this, &cPlayerDefensiveShipsManager::AddDefenderToNextPlanetInQueue, reinforceTime);
		scheduledTasks.insert(scheduler);
		planetsToReinforce.push(cPlanetRecordPtr(planet));

	}
}

void cPlayerDefensiveShipsManager::AddDefenderToNextPlanetInQueue() {
	cPlanetRecordPtr planetToReinforce = planetsToReinforce.front();
	planetsToReinforce.pop();
	auto it = planetDefenderShips.find(planetToReinforce); // If quequed for reinforce the planet will always be on the map.
	if (planetToReinforce->GetStarRecord()->mEmpireID == GetPlayerEmpireID()) { // if the player still controls the planet.
		it->second++;
		if (it->second >= GetMaxDefenders(planetToReinforce.get())) {
			planetDefenderShips.erase(it); // The map only has planets with less than the maximun number of defenders.
		}
		else {
			SimScheduledTaskListenerPtr scheduler = Simulator::ScheduleTask(this, &cPlayerDefensiveShipsManager::AddDefenderToNextPlanetInQueue, reinforceTime); // Still not at maximum defenders so we start another scheduler.
			scheduledTasks.insert(scheduler);
		}
		if (GetCurrentContext() == SpaceContext::Planet && planetToReinforce == GetActivePlanetRecord()) {
			SpawnPlayerDefensiveShip();
		}
	}
	else {
		planetDefenderShips.erase(it);
	}
}

void cPlayerDefensiveShipsManager::ManagePlanetDefenders(cPlanetRecord* planet) {
	auto it = planetDefenderShips.find(planet);
	int numberOfDefenders;
	if (it != planetDefenderShips.end()) {
		numberOfDefenders = it->second;
	}
	else {
		numberOfDefenders = GetMaxDefenders(planet); // If the planet isn't in the map means that the planet has maximum defenders.
	}
	for (int i = 0; i < numberOfDefenders; i++) {
		SpawnPlayerDefensiveShip();
	}
}